# ASP.NET Clean Architecture 

![ASP.NET Core - Clean Architecture](../../img/app-architect/asp-dotnet-core-architect.png){#fig-asp-dotnet-core-architect width="100%"}

## The Three Projects Structure


ASP.NET Core Clean Architecture typically uses **three separate projects** (not just folders!):


```
Solution: CTStrokeAI.sln
â”‚
â”œâ”€â”€ CTStrokeAI.Core/           â† Application Core Project (Red)
â”œâ”€â”€ CTStrokeAI.Infrastructure/ â† Infrastructure Project (Green)
â””â”€â”€ CTStrokeAI.Web/            â† ASP.NET Core Web App (Blue)
```


## Project 1: Application Core (Red) ğŸ”´


### What's Inside


From your first screenshot, the Application Core contains:

```
CTStrokeAI.Core/
â”œâ”€â”€ Entities/
â”‚   â”œâ”€â”€ Patient.cs
â”‚   â”œâ”€â”€ CTScan.cs
â”‚   â””â”€â”€ StrokeResult.cs
â”œâ”€â”€ Interfaces/
â”‚   â”œâ”€â”€ IScanRepository.cs
â”‚   â”œâ”€â”€ IStrokeDetector.cs
â”‚   â””â”€â”€ INotificationService.cs
â”œâ”€â”€ Services/ (Domain Services)
â”‚   â”œâ”€â”€ AspectsCalculator.cs
â”‚   â””â”€â”€ ClinicalAdvisor.cs
â”œâ”€â”€ Aggregates/
â”‚   â””â”€â”€ StrokeAssessmentAggregate.cs
â”œâ”€â”€ ValueObjects/
â”‚   â”œâ”€â”€ AspectsScore.cs
â”‚   â””â”€â”€ PatientAge.cs
â”œâ”€â”€ Specifications/
â”‚   â””â”€â”€ StrokeEligibilitySpec.cs
â”œâ”€â”€ DomainEvents/
â”‚   â””â”€â”€ StrokeDiagnosedEvent.cs
â””â”€â”€ Exceptions/
    â””â”€â”€ InvalidAspectsScoreException.cs
```


### Key Characteristics


```
âœ… Contains:
   â€¢ Pure business logic
   â€¢ Domain entities
   â€¢ Business rules
   â€¢ Interface definitions
   
âŒ Does NOT contain:
   â€¢ Database code
   â€¢ HTTP requests
   â€¢ File I/O
   â€¢ External service calls
   â€¢ ANY infrastructure

Dependencies: NONE (or minimal like System.Collections)
```


### Example Code: Entity (POCO - Plain Old CLR Object)


```csharp
// Core/Entities/Patient.cs
namespace CTStrokeAI.Core.Entities
{
    public class Patient
    {
        public int Id { get; private set; }
        public string HospitalNumber { get; private set; }
        public string Name { get; private set; }
        public DateTime DateOfBirth { get; private set; }
        
        // Pure business logic - no database concerns
        public int GetAge()
        {
            var today = DateTime.Today;
            var age = today.Year - DateOfBirth.Year;
            if (DateOfBirth.Date > today.AddYears(-age)) age--;
            return age;
        }
        
        // Domain rule
        public bool IsEligibleForThrombolysis()
        {
            int age = GetAge();
            return age >= 18 && age <= 80;  // Business rule
        }
    }
}
```


### Example Code: Interface


```csharp
// Core/Interfaces/IScanRepository.cs
namespace CTStrokeAI.Core.Interfaces
{
    public interface IScanRepository
    {
        Task<CTScan> GetByIdAsync(int scanId);
        Task<List<CTScan>> GetByPatientAsync(int patientId);
        Task<CTScan> AddAsync(CTScan scan);
        Task UpdateAsync(CTScan scan);
        Task DeleteAsync(int scanId);
    }
    
    // Core defines WHAT it needs, not HOW it's implemented
}
```


### Example Code: Domain Service


```csharp
// Core/Services/AspectsCalculator.cs
namespace CTStrokeAI.Core.Services
{
    public class AspectsCalculator
    {
        // Pure business logic
        public int CalculateScore(CTScan scan)
        {
            int score = 10; // Start with 10 points
            
            // Business rules for ASPECTS scoring
            if (HasInfarct(scan.M1Region)) score--;
            if (HasInfarct(scan.M2Region)) score--;
            if (HasInfarct(scan.M3Region)) score--;
            // ... more regions
            
            return score;
        }
        
        public string GetRecommendation(int aspectsScore)
        {
            // Clinical decision rules
            return aspectsScore switch
            {
                >= 8 => "Good candidate for thrombolysis",
                >= 6 => "Discuss with stroke team",
                _ => "Large infarct - thrombolysis not recommended"
            };
        }
        
        private bool HasInfarct(RegionData region)
        {
            // Domain logic
            return region.Hypodensity > 0.5;
        }
    }
}
```


## Project 2: Infrastructure (Green) ğŸŸ¢


### What's Inside


From your first screenshot, Infrastructure contains the **implementations**:

```
CTStrokeAI.Infrastructure/
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ EfCoreDbContext.cs       â† Entity Framework
â”‚   â””â”€â”€ Repositories/
â”‚       â”œâ”€â”€ EfScanRepository.cs  â† Implements IScanRepository
â”‚       â””â”€â”€ CacheScanRepository.cs
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ SmsService.cs            â† Implements INotificationService
â”‚   â”œâ”€â”€ EmailService.cs
â”‚   â””â”€â”€ RedisCacheService.cs
â”œâ”€â”€ ExternalApis/
â”‚   â”œâ”€â”€ PacsConnector.cs
â”‚   â”œâ”€â”€ AzureServiceBusAccessor.cs
â”‚   â””â”€â”€ GithubApiClient.cs
â””â”€â”€ InMemoryCache/
    â””â”€â”€ MemoryCacheAdapter.cs
```


### Key Characteristics


```
âœ… Contains:
   â€¢ Database implementations (EF Core)
   â€¢ External API clients
   â€¢ File system operations
   â€¢ Cache implementations
   â€¢ Email/SMS services
   â€¢ Implements interfaces from Core
   
Dependencies:
   â€¢ Application Core (implements its interfaces)
   â€¢ External packages (EF Core, Redis, etc.)
```


### Example Code: Repository Implementation


```csharp
// Infrastructure/Data/Repositories/EfScanRepository.cs
using CTStrokeAI.Core.Entities;
using CTStrokeAI.Core.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CTStrokeAI.Infrastructure.Data.Repositories
{
    public class EfScanRepository : IScanRepository
    {
        private readonly AppDbContext _dbContext;
        
        public EfScanRepository(AppDbContext dbContext)
        {
            _dbContext = dbContext;
        }
        
        public async Task<CTScan> GetByIdAsync(int scanId)
        {
            // Entity Framework implementation
            return await _dbContext.CTScans
                .Include(s => s.Patient)
                .FirstOrDefaultAsync(s => s.Id == scanId);
        }
        
        public async Task<List<CTScan>> GetByPatientAsync(int patientId)
        {
            return await _dbContext.CTScans
                .Where(s => s.PatientId == patientId)
                .OrderByDescending(s => s.AcquisitionDate)
                .ToListAsync();
        }
        
        public async Task<CTScan> AddAsync(CTScan scan)
        {
            await _dbContext.CTScans.AddAsync(scan);
            await _dbContext.SaveChangesAsync();
            return scan;
        }
        
        // ... other methods
    }
}
```


### Example Code: External Service Implementation


```csharp
// Infrastructure/Services/EmailService.cs
using CTStrokeAI.Core.Interfaces;
using SendGrid;
using SendGrid.Helpers.Mail;

namespace CTStrokeAI.Infrastructure.Services
{
    public class EmailService : INotificationService
    {
        private readonly SendGridClient _client;
        private readonly string _fromEmail;
        
        public EmailService(string apiKey, string fromEmail)
        {
            _client = new SendGridClient(apiKey);
            _fromEmail = fromEmail;
        }
        
        public async Task NotifyAsync(string recipient, string message)
        {
            var from = new EmailAddress(_fromEmail);
            var to = new EmailAddress(recipient);
            var msg = MailHelper.CreateSingleEmail(from, to, 
                "Stroke Detection Alert", message, message);
                
            await _client.SendEmailAsync(msg);
        }
    }
}
```


### Example Code: DbContext


```csharp
// Infrastructure/Data/AppDbContext.cs
using Microsoft.EntityFrameworkCore;
using CTStrokeAI.Core.Entities;

namespace CTStrokeAI.Infrastructure.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options)
            : base(options)
        {
        }
        
        public DbSet<Patient> Patients { get; set; }
        public DbSet<CTScan> CTScans { get; set; }
        public DbSet<StrokeResult> StrokeResults { get; set; }
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // EF Core configuration
            modelBuilder.Entity<Patient>()
                .HasMany(p => p.Scans)
                .WithOne(s => s.Patient)
                .HasForeignKey(s => s.PatientId);
        }
    }
}
```


## Project 3: ASP.NET Core Web App (Blue) ğŸ”µ


### What's Inside


From your first screenshot, the Web App contains:

```
CTStrokeAI.Web/
â”œâ”€â”€ Controllers/
â”‚   â”œâ”€â”€ StrokeDetectionController.cs
â”‚   â””â”€â”€ PatientController.cs
â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ StrokeResultViewModel.cs
â”‚   â””â”€â”€ PatientViewModel.cs
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ Home/
â”‚   â””â”€â”€ Stroke/
â”œâ”€â”€ Filters/
â”‚   â”œâ”€â”€ ResponseCachingFilter.cs
â”‚   â””â”€â”€ ModelValidationFilter.cs
â”œâ”€â”€ Program.cs              â† Entry point
â”œâ”€â”€ Startup.cs              â† DI configuration
â””â”€â”€ appsettings.json
```


### Key Characteristics


```
âœ… Contains:
   â€¢ MVC Controllers
   â€¢ Razor Views
   â€¢ ViewModels (DTOs)
   â€¢ Filters/Middleware
   â€¢ Dependency injection setup
   â€¢ HTTP concerns
   
Dependencies:
   â€¢ Application Core
   â€¢ Infrastructure (at startup only)
```


### Example Code: Controller


```csharp
// Web/Controllers/StrokeDetectionController.cs
using Microsoft.AspNetCore.Mvc;
using CTStrokeAI.Core.Interfaces;
using CTStrokeAI.Core.Services;

namespace CTStrokeAI.Web.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class StrokeDetectionController : ControllerBase
    {
        private readonly IScanRepository _scanRepo;
        private readonly AspectsCalculator _calculator;
        private readonly INotificationService _notifier;
        
        public StrokeDetectionController(
            IScanRepository scanRepo,
            AspectsCalculator calculator,
            INotificationService notifier)
        {
            _scanRepo = scanRepo;
            _calculator = calculator;
            _notifier = notifier;
        }
        
        [HttpPost("analyze/{scanId}")]
        public async Task<IActionResult> AnalyzeScan(int scanId)
        {
            // Get scan using interface (don't care about implementation!)
            var scan = await _scanRepo.GetByIdAsync(scanId);
            
            if (scan == null)
                return NotFound();
            
            // Use business logic from Core
            int aspectsScore = _calculator.CalculateScore(scan);
            string recommendation = _calculator.GetRecommendation(aspectsScore);
            
            // Notify using interface
            if (aspectsScore <= 5)
            {
                await _notifier.NotifyAsync(
                    "stroke-team@ramathibodi.go.th",
                    $"Critical: Low ASPECTS score ({aspectsScore}) for scan {scanId}"
                );
            }
            
            // Return ViewModel
            return Ok(new StrokeResultViewModel
            {
                ScanId = scanId,
                AspectsScore = aspectsScore,
                Recommendation = recommendation
            });
        }
    }
}
```


### Example Code: Dependency Injection Setup


```csharp
// Web/Program.cs (ASP.NET Core 6+)
using CTStrokeAI.Core.Interfaces;
using CTStrokeAI.Core.Services;
using CTStrokeAI.Infrastructure.Data;
using CTStrokeAI.Infrastructure.Data.Repositories;
using CTStrokeAI.Infrastructure.Services;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddControllers();

// Database
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("DefaultConnection")
    ));

// Register Core services
builder.Services.AddScoped<AspectsCalculator>();

// Register Infrastructure implementations
builder.Services.AddScoped<IScanRepository, EfScanRepository>();
builder.Services.AddScoped<INotificationService, EmailService>(sp =>
    new EmailService(
        builder.Configuration["SendGrid:ApiKey"],
        builder.Configuration["SendGrid:FromEmail"]
    ));

// Add caching
builder.Services.AddMemoryCache();
builder.Services.AddScoped<INotificationService, SmsService>();

var app = builder.Build();

// Configure the HTTP request pipeline
app.UseRouting();
app.MapControllers();

app.Run();
```


## Dependency Flow Visualization


### Compile-Time Dependencies


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ASP.NET Core Web App (Blue)             â”‚
â”‚                                                 â”‚
â”‚  Controllers, Views, Filters                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                â”‚
              â”‚ references     â”‚ references
              â”‚                â”‚ (startup only)
              â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application Core    â”‚  â”‚  Infrastructure        â”‚
â”‚     (Red)           â”‚  â”‚     (Green)            â”‚
â”‚                     â”‚  â”‚                        â”‚
â”‚ â€¢ Entities          â”‚  â”‚ â€¢ EF Core DbContext    â”‚
â”‚ â€¢ Interfaces        â”‚â—„â”€â”¤ â€¢ Repositories (impl)  â”‚
â”‚ â€¢ Domain Services   â”‚  â”‚ â€¢ External APIs        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â€¢ Email/SMS Services   â”‚
         â–²               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚
         â”‚ NO dependency!          â”‚ uses
         â”‚                         â–¼
         â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚               â”‚ External Resources  â”‚
         â”‚               â”‚ â€¢ SQL Database      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â€¢ Redis Cache       â”‚
                         â”‚ â€¢ SendGrid API      â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key: Infrastructure depends on Core
     Core depends on NOTHING
     Web depends on both (but uses Core interfaces)
```


### Runtime Dependencies (via Dependency Injection)


```
HTTP Request arrives
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Controller    â”‚
â”‚                 â”‚
â”‚  Needs:         â”‚
â”‚  â€¢ IScanRepo    â”‚â—„â”€â”€â”
â”‚  â€¢ INotifier    â”‚â—„â”€â”€â”¤  DI Container injects
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  concrete implementations
                      â”‚
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EfScanRepo     â”‚         â”‚  EmailService     â”‚
â”‚ (from Infra)   â”‚         â”‚  (from Infra)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Controller only knows about interfaces!
DI provides the implementations at runtime
```


## Testing Strategy


### Unit Tests (Figure 5-10) - Test Application Core

![ASP.NET Unittest](../../img/app-architect/unit-test.png){#fig-asp-dotnet-unit-test width="80%"}

From your second screenshot, **Unit Tests target Application Core in isolation**:


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Unit Test Project              â”‚
â”‚                  (Green)                    â”‚
â”‚                                             â”‚
â”‚  Tests pure business logic with NO external â”‚
â”‚  dependencies                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â”‚ tests
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Application Core (Red)             â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚   Entities + Interfaces   â”‚              â”‚
â”‚  â”‚   Domain Services         â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

NO Database, NO APIs, NO External Services!
Fast, isolated, reliable tests
```


**Example - Unit Test:**

```csharp
// Tests/Core/Services/AspectsCalculatorTests.cs
using Xunit;
using CTStrokeAI.Core.Services;
using CTStrokeAI.Core.Entities;

namespace CTStrokeAI.Tests.Core.Services
{
    public class AspectsCalculatorTests
    {
        [Fact]
        public void CalculateScore_NoInfarcts_ReturnsFullScore()
        {
            // Arrange
            var calculator = new AspectsCalculator();
            var scan = new CTScan
            {
                M1Region = new RegionData { Hypodensity = 0.1 },
                M2Region = new RegionData { Hypodensity = 0.1 },
                M3Region = new RegionData { Hypodensity = 0.1 }
                // All regions normal
            };
            
            // Act
            int score = calculator.CalculateScore(scan);
            
            // Assert
            Assert.Equal(10, score);
        }
        
        [Fact]
        public void GetRecommendation_HighScore_RecommendsThrombolysis()
        {
            // Arrange
            var calculator = new AspectsCalculator();
            
            // Act
            string recommendation = calculator.GetRecommendation(9);
            
            // Assert
            Assert.Contains("thrombolysis", recommendation.ToLower());
        }
        
        [Theory]
        [InlineData(10, "Good candidate")]
        [InlineData(8, "Good candidate")]
        [InlineData(7, "Discuss with stroke team")]
        [InlineData(5, "not recommended")]
        public void GetRecommendation_VariousScores_ReturnsExpected(
            int score, string expectedText)
        {
            // Arrange
            var calculator = new AspectsCalculator();
            
            // Act
            string recommendation = calculator.GetRecommendation(score);
            
            // Assert
            Assert.Contains(expectedText, recommendation);
        }
    }
}
```


**Unit Test with Mock (Test with Interface):**

```csharp
// Tests/Core/Services/PatientServiceTests.cs
using Xunit;
using Moq;
using CTStrokeAI.Core.Interfaces;
using CTStrokeAI.Core.Services;
using CTStrokeAI.Core.Entities;

namespace CTStrokeAI.Tests.Core.Services
{
    public class PatientServiceTests
    {
        [Fact]
        public async Task ProcessStrokeScan_CriticalCase_SendsNotification()
        {
            // Arrange
            var mockNotifier = new Mock<INotificationService>();
            var mockRepo = new Mock<IScanRepository>();
            
            var scan = new CTScan { Id = 1, PatientId = 100 };
            mockRepo.Setup(r => r.GetByIdAsync(1))
                .ReturnsAsync(scan);
            
            var calculator = new AspectsCalculator();
            var service = new StrokeAnalysisService(
                mockRepo.Object,
                calculator,
                mockNotifier.Object
            );
            
            // Act
            await service.AnalyzeScanAsync(1);
            
            // Assert
            mockNotifier.Verify(
                n => n.NotifyAsync(
                    It.IsAny<string>(),
                    It.IsAny<string>()),
                Times.Once
            );
        }
    }
}
```


**Benefits of Unit Tests:**

```
âœ… FAST: No database, no network, no I/O
âœ… ISOLATED: Test business logic alone
âœ… RELIABLE: No external dependencies = no flaky tests
âœ… EASY TO WRITE: Simple setup, no infrastructure

Test Speed:
Unit Tests: ~1-10 ms per test
Integration Tests: ~100-1000 ms per test
```


### Integration Tests (Figure 5-11) - Test Infrastructure

![ASP.NET Integration Test](../../img/app-architect/integration-test.png){#fig-asp-dotnet-integration-test width="80%"}

From your third screenshot, **Integration Tests target Infrastructure with real dependencies**:


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Integration Test Project             â”‚
â”‚              (Green)                         â”‚
â”‚                                              â”‚
â”‚  Tests infrastructure implementations with   â”‚
â”‚  REAL external dependencies                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â”‚ tests
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Infrastructure (Yellow)               â”‚
â”‚                                              â”‚
â”‚  â€¢ Repositories                              â”‚
â”‚  â€¢ External API clients                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ connects to
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       External Dependencies                  â”‚
â”‚  â€¢ SQL Database (test DB)                    â”‚
â”‚  â€¢ Cloud Storage                             â”‚
â”‚  â€¢ Email service                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Uses REAL infrastructure
Tests actual implementations
```


**Example - Integration Test:**

```csharp
// Tests/Infrastructure/Data/EfScanRepositoryTests.cs
using Xunit;
using Microsoft.EntityFrameworkCore;
using CTStrokeAI.Infrastructure.Data;
using CTStrokeAI.Infrastructure.Data.Repositories;
using CTStrokeAI.Core.Entities;

namespace CTStrokeAI.Tests.Infrastructure.Data
{
    public class EfScanRepositoryTests : IDisposable
    {
        private readonly AppDbContext _context;
        private readonly EfScanRepository _repository;
        
        public EfScanRepositoryTests()
        {
            // Use in-memory database for testing
            var options = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
                .Options;
            
            _context = new AppDbContext(options);
            _repository = new EfScanRepository(_context);
        }
        
        [Fact]
        public async Task AddAsync_ValidScan_SavesToDatabase()
        {
            // Arrange
            var patient = new Patient { HospitalNumber = "HN001" };
            var scan = new CTScan
            {
                Patient = patient,
                AcquisitionDate = DateTime.Now,
                Modality = "CT"
            };
            
            // Act
            var result = await _repository.AddAsync(scan);
            
            // Assert
            Assert.NotEqual(0, result.Id); // ID was assigned
            var savedScan = await _repository.GetByIdAsync(result.Id);
            Assert.NotNull(savedScan);
            Assert.Equal("CT", savedScan.Modality);
        }
        
        [Fact]
        public async Task GetByPatientAsync_MultipleScans_ReturnsAllScans()
        {
            // Arrange
            var patient = new Patient { HospitalNumber = "HN002" };
            await _context.Patients.AddAsync(patient);
            await _context.SaveChangesAsync();
            
            await _repository.AddAsync(new CTScan
            {
                PatientId = patient.Id,
                AcquisitionDate = DateTime.Now.AddDays(-2)
            });
            await _repository.AddAsync(new CTScan
            {
                PatientId = patient.Id,
                AcquisitionDate = DateTime.Now.AddDays(-1)
            });
            
            // Act
            var scans = await _repository.GetByPatientAsync(patient.Id);
            
            // Assert
            Assert.Equal(2, scans.Count);
            Assert.True(scans[0].AcquisitionDate > scans[1].AcquisitionDate);
            // Should be ordered by date descending
        }
        
        public void Dispose()
        {
            _context.Dispose();
        }
    }
}
```


**Integration Test with Real Database:**

```csharp
// Tests/Infrastructure/ExternalApis/PacsConnectorTests.cs
using Xunit;
using CTStrokeAI.Infrastructure.ExternalApis;

namespace CTStrokeAI.Tests.Infrastructure.ExternalApis
{
    // These tests require a real test PACS server
    [Collection("PACS Tests")]
    public class PacsConnectorTests
    {
        private readonly string _testPacsHost = "test-pacs.ramathibodi.local";
        private readonly int _testPacsPort = 11112;
        
        [Fact]
        public async Task QueryStudy_ValidStudyId_ReturnsData()
        {
            // Arrange
            var connector = new PacsConnector(_testPacsHost, _testPacsPort);
            string testStudyId = "1.2.840.113619.2.55.3.test";
            
            // Act
            var study = await connector.QueryStudyAsync(testStudyId);
            
            // Assert
            Assert.NotNull(study);
            Assert.Equal(testStudyId, study.StudyInstanceUID);
        }
        
        [Fact]
        public async Task RetrieveSeries_ExistingSeries_DownloadsImages()
        {
            // Arrange
            var connector = new PacsConnector(_testPacsHost, _testPacsPort);
            
            // Act
            var images = await connector.RetrieveSeriesAsync(
                "1.2.840.test.series"
            );
            
            // Assert
            Assert.NotEmpty(images);
            Assert.True(images.Count > 0);
        }
    }
}
```


## Complete Radiology AI Example


### Project Structure


```
CTStrokeAI.sln
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ CTStrokeAI.Core/              â† Application Core
â”‚   â”‚   â”œâ”€â”€ Entities/
â”‚   â”‚   â”‚   â”œâ”€â”€ Patient.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ CTScan.cs
â”‚   â”‚   â”‚   â””â”€â”€ StrokeResult.cs
â”‚   â”‚   â”œâ”€â”€ Interfaces/
â”‚   â”‚   â”‚   â”œâ”€â”€ IScanRepository.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ IModelService.cs
â”‚   â”‚   â”‚   â””â”€â”€ INotificationService.cs
â”‚   â”‚   â””â”€â”€ Services/
â”‚   â”‚       â”œâ”€â”€ AspectsCalculator.cs
â”‚   â”‚       â””â”€â”€ StrokeAnalysisService.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ CTStrokeAI.Infrastructure/    â† Infrastructure
â”‚   â”‚   â”œâ”€â”€ Data/
â”‚   â”‚   â”‚   â”œâ”€â”€ AppDbContext.cs
â”‚   â”‚   â”‚   â””â”€â”€ Repositories/
â”‚   â”‚   â”‚       â””â”€â”€ EfScanRepository.cs
â”‚   â”‚   â”œâ”€â”€ Services/
â”‚   â”‚   â”‚   â”œâ”€â”€ TensorFlowModelService.cs
â”‚   â”‚   â”‚   â””â”€â”€ SendGridEmailService.cs
â”‚   â”‚   â””â”€â”€ ExternalApis/
â”‚   â”‚       â””â”€â”€ PacsConnector.cs
â”‚   â”‚
â”‚   â””â”€â”€ CTStrokeAI.Web/               â† ASP.NET Core Web
â”‚       â”œâ”€â”€ Controllers/
â”‚       â”‚   â””â”€â”€ StrokeController.cs
â”‚       â”œâ”€â”€ ViewModels/
â”‚       â”‚   â””â”€â”€ StrokeResultViewModel.cs
â”‚       â”œâ”€â”€ Program.cs
â”‚       â””â”€â”€ appsettings.json
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ CTStrokeAI.UnitTests/         â† Unit Tests
    â”‚   â””â”€â”€ Core/
    â”‚       â””â”€â”€ Services/
    â”‚           â””â”€â”€ AspectsCalculatorTests.cs
    â”‚
    â””â”€â”€ CTStrokeAI.IntegrationTests/  â† Integration Tests
        â””â”€â”€ Infrastructure/
            â””â”€â”€ Data/
                â””â”€â”€ EfScanRepositoryTests.cs
```


### Dependency Graph


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CTStrokeAI.Web                       â”‚
â”‚                                                       â”‚
â”‚  Program.cs â”€â”                                        â”‚
â”‚              â”‚  configures DI                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                â”‚                 â”‚
       â–¼                â–¼                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  Core       â”‚  â”‚ Infrastructure â”‚       â”‚
â”‚  (Pure)     â”‚â—„â”€â”¤ (Implements)   â”‚       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
                          â”‚               â”‚
                          â–¼               â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
                 â”‚  EF Core       â”‚       â”‚
                 â”‚  SendGrid      â”‚       â”‚
                 â”‚  pydicom       â”‚       â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
                                          â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Unit Tests    â”‚  (test Core)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Integration   â”‚  (test Infrastructure)
â”‚  Tests         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


## Key Benefits of This Architecture


### 1. Testability


```
Unit Tests:
âœ… Test business logic in isolation
âœ… Fast (milliseconds)
âœ… No external dependencies
âœ… Run on every commit

Integration Tests:
âœ… Test infrastructure with real systems
âœ… Catch integration issues
âœ… Confidence before deployment
```


### 2. Flexibility


```
Switch Database:
SQL Server â†’ PostgreSQL
Just change Infrastructure project
Core remains unchanged!

Switch Notification:
Email â†’ SMS â†’ Slack
Just change Infrastructure project
Core remains unchanged!
```


### 3. Maintainability


```
Clear separation:
â€¢ Core = Business rules (rarely changes)
â€¢ Infrastructure = Tech details (changes often)
â€¢ Web = UI/API (changes frequently)

Each team can work independently
```


### 4. Framework Independence


```
Application Core has NO dependency on:
âŒ ASP.NET Core
âŒ Entity Framework
âŒ Any external library

Can move to:
âœ… Different web framework (Blazor, gRPC)
âœ… Different ORM (Dapper, NPoco)
âœ… Different platform (Azure Functions, AWS Lambda)
```


## Summary


**ASP.NET Core Clean Architecture** uses **three projects**:


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Web (Blue) - ASP.NET Core              â”‚
â”‚  â€¢ Controllers, Views, Filters          â”‚
â”‚  â€¢ Coordinates requests                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ depends on both
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼        â–¼                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ Core   â”‚  â”‚ Infrastructure   â”‚  â”‚
â”‚ (Red)  â”‚â—„â”€â”¤ (Green)          â”‚  â”‚
â”‚        â”‚  â”‚                  â”‚  â”‚
â”‚ Pure   â”‚  â”‚ Implements       â”‚  â”‚
â”‚ Logic  â”‚  â”‚ interfaces       â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                   â”‚              â”‚
                   â–¼              â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
            â”‚  External    â”‚      â”‚
            â”‚  Systems     â”‚      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
                                  â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
            â”‚  Unit Tests      â”‚â”€â”€â”˜
            â”‚  (Green)         â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Integration     â”‚
            â”‚  Tests (Green)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


**Three key principles:**

1. **Dependency Inversion**: Infrastructure â†’ Core (not Core â†’ Infrastructure)
2. **Interface Segregation**: Core defines interfaces, Infrastructure implements
3. **Separation of Concerns**: Each project has ONE responsibility
