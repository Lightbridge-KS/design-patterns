# Clean Architecture

- [Common Web App Architecture (Microsoft)](https://learn.microsoft.com/en-gb/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures)

## Core Concept: Dependency Inversion


Clean Architecture is fundamentally about **reversing the traditional dependency direction**. Instead of business logic depending on infrastructure, **infrastructure depends on business logic**.


### Traditional Architecture (âŒ Problems)


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Interface                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ depends on
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Business Logic                     â”‚
â”‚  â€¢ Calls database directly          â”‚
â”‚  â€¢ Depends on specific DB (SQL)     â”‚
â”‚  â€¢ Tightly coupled to infrastructureâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ depends on
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Data Access / Infrastructure       â”‚
â”‚  â€¢ SQL Server specific code         â”‚
â”‚  â€¢ File system operations           â”‚
â”‚  â€¢ External API calls               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Problem: Business logic knows about database!
Can't test without database
Can't swap databases easily
```


### Clean Architecture (âœ… Solution)


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Interface                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ depends on
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application Core (Business Logic)  â”‚
â”‚  â€¢ Defines INTERFACES               â”‚
â”‚  â€¢ Contains domain models           â”‚
â”‚  â€¢ Pure business rules              â”‚
â”‚  â€¢ NO infrastructure knowledge      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ defines interfaces
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Infrastructure                     â”‚
â”‚  â€¢ IMPLEMENTS those interfaces      â”‚
â”‚  â€¢ SQL/PostgreSQL/MongoDB           â”‚
â”‚  â€¢ File system                      â”‚
â”‚  â€¢ External APIs                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²
         â”‚ implements interfaces from
         â””â”€ Dependency points INWARD!

Benefit: Business logic is independent!
Easy to test (mock interfaces)
Easy to swap implementations
```


## The Onion Architecture View

![Clean Architecture (Onion)](../../img/app-architect/clean-architect-onion.png){#fig-clean-architect-onion width="80%"}

From your first image, let's break down each layer:


```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         OUTER LAYER (Gray)              â”‚
        â”‚                                         â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
        â”‚  â”‚   User Interface        â”‚            â”‚
        â”‚  â”‚   â€¢ Controllers         â”‚            â”‚
        â”‚  â”‚   â€¢ View Models         â”‚            â”‚
        â”‚  â”‚   â€¢ API Endpoints       â”‚            â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
        â”‚             â”‚                           â”‚
        â”‚             â”‚ uses                      â”‚
        â”‚             â–¼                           â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
        â”‚  â”‚   MIDDLE LAYER (Orange)      â”‚       â”‚
        â”‚  â”‚   Application Core           â”‚       â”‚
        â”‚  â”‚                              â”‚       â”‚
        â”‚  â”‚   Domain Services            â”‚       â”‚
        â”‚  â”‚   Business Rules             â”‚       â”‚
        â”‚  â”‚                              â”‚       â”‚
        â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚       â”‚
        â”‚  â”‚   â”‚  INNER CORE        â”‚     â”‚       â”‚
        â”‚  â”‚   â”‚  â€¢ Entities        â”‚     â”‚       â”‚
        â”‚  â”‚   â”‚  â€¢ Interfaces      â”‚     â”‚       â”‚
        â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚       â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
        â”‚             â–²                           â”‚
        â”‚             â”‚ implements                â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
        â”‚  â”‚   Infrastructure        â”‚            â”‚
        â”‚  â”‚   â€¢ Repositories        â”‚            â”‚
        â”‚  â”‚   â€¢ Impl. Services      â”‚            â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
        â”‚                                         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–²
                      â”‚ connects to
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  External Dependencies       â”‚
        â”‚  â€¢ SQL Database              â”‚
        â”‚  â€¢ Cloud Storage             â”‚
        â”‚  â€¢ Email Service             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key Rule: Dependencies flow INWARD â†’
Inner layers know nothing about outer layers
```


## The Three Core Layers


### Layer 1: Application Core (The Heart) ğŸ§¡


**What it contains:**

```
Application Core/
â”œâ”€â”€ Entities/
â”‚   â”œâ”€â”€ Patient.py
â”‚   â”œâ”€â”€ CTScan.py
â”‚   â””â”€â”€ StrokeResult.py
â”œâ”€â”€ Interfaces/
â”‚   â”œâ”€â”€ IDicomRepository.py
â”‚   â”œâ”€â”€ IStrokeDetector.py
â”‚   â””â”€â”€ INotificationService.py
â””â”€â”€ Services/
    â”œâ”€â”€ AspectsCalculator.py
    â””â”€â”€ ClinicalRecommendation.py
```

**Characteristics:**

- **NO** dependencies on external libraries (except maybe core Python)
- **NO** knowledge of databases, APIs, UI frameworks
- Contains **pure business logic**
- Defines **interfaces** (contracts) for what it needs


**Example - Patient Entity:**

```python
# entities/patient.py
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Patient:
    """Pure domain entity - no database, no infrastructure"""
    patient_id: str
    name: str
    date_of_birth: datetime
    hn: str  # Hospital Number
    
    def get_age(self) -> int:
        """Pure business logic"""
        today = datetime.now()
        return today.year - self.date_of_birth.year
```


**Example - Interface Definition:**

```python
# interfaces/idicom_repository.py
from abc import ABC, abstractmethod
from entities.ct_scan import CTScan

class IDicomRepository(ABC):
    """Interface defined in Application Core"""
    
    @abstractmethod
    def get_scan_by_id(self, scan_id: str) -> CTScan:
        """Get CT scan - HOW is not specified here!"""
        pass
    
    @abstractmethod
    def save_scan(self, scan: CTScan) -> None:
        """Save CT scan - Could be SQL, MongoDB, file system!"""
        pass
```

**The core doesn't care HOW, just WHAT!**


### Layer 2: Infrastructure (The Implementation) ğŸŸ¡


**What it contains:**

```
Infrastructure/
â”œâ”€â”€ Repositories/
â”‚   â”œâ”€â”€ SqlDicomRepository.py      â† Implements IDicomRepository
â”‚   â”œâ”€â”€ PacsDicomRepository.py     â† Also implements IDicomRepository
â”‚   â””â”€â”€ FileDicomRepository.py     â† Another implementation!
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ EmailNotificationService.py â† Implements INotificationService
â”‚   â””â”€â”€ SmsNotificationService.py   â† Alternative implementation
â””â”€â”€ ExternalApis/
    â””â”€â”€ PacsConnector.py
```

**Characteristics:**
- **Implements interfaces** from Application Core
- Contains **all infrastructure code**: databases, files, APIs, etc.
- **Depends on** Application Core
- Can be **swapped** without changing business logic


**Example - SQL Implementation:**

```python
# infrastructure/repositories/sql_dicom_repository.py
from sqlalchemy.orm import Session
from interfaces.idicom_repository import IDicomRepository  # â† From Core!
from entities.ct_scan import CTScan  # â† From Core!

class SqlDicomRepository(IDicomRepository):
    """SQL implementation of the interface"""
    
    def __init__(self, db_session: Session):
        self.db = db_session
    
    def get_scan_by_id(self, scan_id: str) -> CTScan:
        """Implementation uses SQL"""
        result = self.db.query(CTScanModel).filter_by(id=scan_id).first()
        return self._map_to_entity(result)
    
    def save_scan(self, scan: CTScan) -> None:
        """Implementation uses SQL"""
        model = self._map_to_model(scan)
        self.db.add(model)
        self.db.commit()
```


**Example - PACS Implementation:**

```python
# infrastructure/repositories/pacs_dicom_repository.py
from pynetdicom import AE
from interfaces.idicom_repository import IDicomRepository  # â† Same interface!
from entities.ct_scan import CTScan

class PacsDicomRepository(IDicomRepository):
    """PACS implementation of the SAME interface"""
    
    def __init__(self, pacs_host: str, pacs_port: int):
        self.ae = AE()
        self.host = pacs_host
        self.port = pacs_port
    
    def get_scan_by_id(self, scan_id: str) -> CTScan:
        """Implementation uses DICOM network protocol"""
        # Query PACS using DIMSE
        dataset = self._query_pacs(scan_id)
        return self._convert_to_entity(dataset)
    
    def save_scan(self, scan: CTScan) -> None:
        """Implementation sends to PACS"""
        dataset = self._convert_to_dicom(scan)
        self._store_to_pacs(dataset)
```

**Same interface, completely different implementation!**


### Layer 3: User Interface (The Presentation) ğŸ”µ


**What it contains:**

```
UserInterface/
â”œâ”€â”€ Api/
â”‚   â”œâ”€â”€ Controllers/
â”‚   â”‚   â”œâ”€â”€ StrokeDetectionController.py
â”‚   â”‚   â””â”€â”€ PatientController.py
â”‚   â””â”€â”€ ViewModels/
â”‚       â”œâ”€â”€ StrokeResultViewModel.py
â”‚       â””â”€â”€ PatientViewModel.py
â””â”€â”€ Web/
    â”œâ”€â”€ templates/
    â””â”€â”€ static/
```

**Characteristics:**
- Handles user interaction (HTTP requests, CLI, GUI)
- **Depends on** Application Core
- Converts between user format and domain format
- **NO business logic** here!


**Example - API Controller:**

```python
# api/controllers/stroke_detection_controller.py
from fastapi import APIRouter, Depends
from interfaces.idicom_repository import IDicomRepository
from services.aspects_calculator import AspectsCalculator

router = APIRouter()

@router.post("/detect-stroke")
def detect_stroke(
    study_id: str,
    # Dependency injection - we don't care which implementation!
    dicom_repo: IDicomRepository = Depends(get_dicom_repository)
):
    """UI layer - just coordinates, no business logic"""
    
    # Get data using interface
    ct_scan = dicom_repo.get_scan_by_id(study_id)
    
    # Use business logic from Application Core
    calculator = AspectsCalculator()
    aspects_score = calculator.calculate(ct_scan)
    
    # Return as JSON (UI concern)
    return {
        "study_id": study_id,
        "aspects_score": aspects_score,
        "status": "completed"
    }
```


## Dependency Flow Visualization

![Clean Architecture (layers)](../../img/app-architect/clean-architect-layers.png){#fig-clean-architect-layers width="80%"}

From your second image, here's the dependency direction:


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           User Interface (Blue)               â”‚
â”‚  â€¢ FastAPI routes                             â”‚
â”‚  â€¢ React frontend                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â”‚ Solid arrow = Compile-time dependency
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Application Core (Red)              â”‚
â”‚  â€¢ Business Logic                        â”‚
â”‚  â€¢ Entities                              â”‚
â”‚  â€¢ Interfaces (contracts)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â–²                 â–²
                   â”‚                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                â”‚   â”‚               â”‚
         â”‚ Implements     â”‚   â”‚ Uses (test)   â”‚
         â”‚                â”‚   â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
â”‚ Infrastructure  â”‚    â”‚    Tests    â”‚
â”‚ (Yellow)        â”‚    â”‚  (Purple)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key insight: Infrastructure knows about Core
            Core doesn't know about Infrastructure!
```


## Real-World Radiology AI Example


### Scenario: CT Stroke Detection System


**Application Core (Business Logic):**

```python
# core/entities/ct_scan.py
@dataclass
class CTScan:
    scan_id: str
    patient_id: str
    acquisition_date: datetime
    modality: str
    image_data: np.ndarray  # Pure data, no storage concern

# core/interfaces/iscan_repository.py
class IScanRepository(ABC):
    @abstractmethod
    def get_scan(self, scan_id: str) -> CTScan:
        pass

# core/services/stroke_detector.py
class StrokeDetector:
    """Pure business logic - no infrastructure!"""
    
    def __init__(self, model_path: str):
        self.model = self._load_model(model_path)
    
    def calculate_aspects(self, scan: CTScan) -> int:
        """Business rule: ASPECTS scoring"""
        predictions = self.model.predict(scan.image_data)
        score = self._calculate_score(predictions)
        return score
    
    def generate_recommendation(self, aspects_score: int) -> str:
        """Business rule: Clinical recommendation"""
        if aspects_score >= 8:
            return "Consider thrombolysis if within window"
        elif aspects_score >= 6:
            return "Consult stroke team for case discussion"
        else:
            return "Large infarct - thrombolysis not recommended"
```


**Infrastructure (Multiple Implementations):**

```python
# infrastructure/repositories/pacs_repository.py
class PacsRepository(IScanRepository):
    """Production: Get from hospital PACS"""
    def get_scan(self, scan_id: str) -> CTScan:
        # Complex DICOM network code
        pass

# infrastructure/repositories/file_repository.py
class FileRepository(IScanRepository):
    """Development: Get from local files"""
    def get_scan(self, scan_id: str) -> CTScan:
        # Simple file reading
        pass

# infrastructure/repositories/mock_repository.py
class MockRepository(IScanRepository):
    """Testing: Return fake data"""
    def get_scan(self, scan_id: str) -> CTScan:
        return CTScan(
            scan_id="TEST001",
            patient_id="P001",
            acquisition_date=datetime.now(),
            modality="CT",
            image_data=np.zeros((512, 512))  # Fake image
        )
```


**User Interface (API):**

```python
# api/main.py
from fastapi import FastAPI, Depends

app = FastAPI()

def get_repository() -> IScanRepository:
    """Dependency injection - choose implementation"""
    if settings.ENV == "production":
        return PacsRepository()
    elif settings.ENV == "development":
        return FileRepository()
    else:
        return MockRepository()

@app.post("/analyze")
def analyze_stroke(
    scan_id: str,
    repo: IScanRepository = Depends(get_repository)
):
    # Get scan (don't care from where!)
    scan = repo.get_scan(scan_id)
    
    # Run business logic
    detector = StrokeDetector(model_path="model.h5")
    aspects_score = detector.calculate_aspects(scan)
    recommendation = detector.generate_recommendation(aspects_score)
    
    return {
        "aspects_score": aspects_score,
        "recommendation": recommendation
    }
```


## Benefits of Clean Architecture


### 1. Easy Testing


```python
# tests/test_stroke_detector.py
def test_aspects_calculation():
    # Use mock repository - no real PACS needed!
    mock_repo = MockRepository()
    scan = mock_repo.get_scan("TEST001")
    
    detector = StrokeDetector(model_path="test_model.h5")
    score = detector.calculate_aspects(scan)
    
    assert score >= 0 and score <= 10
```

**No database, no PACS, no network - just pure logic testing!**


### 2. Easy Swapping


```python
# Swap from PACS to cloud storage:

# Before:
repository = PacsRepository(host="pacs.hospital.local")

# After (just change ONE line):
repository = CloudRepository(bucket="ct-scans-asia")

# Business logic stays EXACTLY the same!
detector = StrokeDetector(model_path="model.h5")
scan = repository.get_scan(scan_id)  # â† Same interface
result = detector.calculate_aspects(scan)  # â† Same logic
```


### 3. Independent Development


```
Team 1: Application Core          Team 2: Infrastructure
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Define interfaces   â”‚  â”€â”€â”€â”€â”€â”€> â”‚ Implement interfaces â”‚
â”‚ Write business      â”‚          â”‚ Build PACS connector â”‚
â”‚ logic               â”‚          â”‚ Set up database      â”‚
â”‚                     â”‚          â”‚                      â”‚
â”‚ Can work with       â”‚          â”‚ Can work separately  â”‚
â”‚ mock data           â”‚          â”‚ as long as interface â”‚
â”‚                     â”‚          â”‚ is followed          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Both teams work independently!
Integration is just wiring up interfaces
```


### 4. Framework Independence


Your Application Core doesn't depend on:
- FastAPI
- SQLAlchemy  
- pydicom
- Any external library!

```
Today:  FastAPI + PostgreSQL + PACS
Tomorrow: Django + MongoDB + Cloud Storage
Next year: GraphQL + DynamoDB + S3

Application Core stays the same! âœ¨
```


## Project Structure Example


```
ct-stroke-ai/
â”œâ”€â”€ core/                          â† Application Core
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ patient.py
â”‚   â”‚   â”œâ”€â”€ ct_scan.py
â”‚   â”‚   â””â”€â”€ stroke_result.py
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”œâ”€â”€ iscan_repository.py
â”‚   â”‚   â”œâ”€â”€ imodel_service.py
â”‚   â”‚   â””â”€â”€ inotification_service.py
â”‚   â””â”€â”€ services/
â”‚       â”œâ”€â”€ stroke_detector.py
â”‚       â”œâ”€â”€ aspects_calculator.py
â”‚       â””â”€â”€ clinical_advisor.py
â”‚
â”œâ”€â”€ infrastructure/                â† Infrastructure
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ pacs_repository.py
â”‚   â”‚   â”œâ”€â”€ sql_repository.py
â”‚   â”‚   â””â”€â”€ file_repository.py
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ tensorflow_model_service.py
â”‚   â”‚   â””â”€â”€ email_notification_service.py
â”‚   â””â”€â”€ database/
â”‚       â””â”€â”€ postgres_context.py
â”‚
â”œâ”€â”€ api/                           â† User Interface
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â””â”€â”€ stroke_controller.py
â”‚   â”œâ”€â”€ viewmodels/
â”‚   â”‚   â””â”€â”€ stroke_result_vm.py
â”‚   â””â”€â”€ main.py
â”‚
â””â”€â”€ tests/                         â† Tests
    â”œâ”€â”€ unit/
    â”‚   â””â”€â”€ test_stroke_detector.py
    â””â”€â”€ integration/
        â””â”€â”€ test_api.py
```


## Key Principles Summary


### 1. Dependency Inversion Principle


```
âŒ WRONG:
Core â†’ depends on â†’ Infrastructure

âœ… RIGHT:
Core â† depended on by â† Infrastructure
```


### 2. Interface Segregation


```
Core defines interfaces:
interface IScanRepository {
    get_scan()
    save_scan()
}

Infrastructure implements:
class PacsRepository implements IScanRepository
class FileRepository implements IScanRepository
class CloudRepository implements IScanRepository
```


### 3. Single Responsibility


```
âœ… Application Core: Business rules ONLY
âœ… Infrastructure: Technical implementation ONLY
âœ… UI: User interaction ONLY
```


## When to Use Clean Architecture?


**âœ… Use when:**

- Complex business logic
- Long-term project (years)
- Multiple developers/teams
- Need flexibility to change tech stack
- High testability requirements
- Your radiology AI systems! ğŸ¥


**âŒ Overkill for:**

- Simple CRUD apps
- Prototypes
- Short-lived projects
- Solo weekend projects


## Summary


**Clean Architecture** = **Onion Architecture** = **Hexagonal Architecture**

**Core idea:** Business logic at the center, everything else depends on it.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  The Dependency Rule:               â”‚
â”‚                                     â”‚
â”‚  Source code dependencies           â”‚
â”‚  point INWARD only                  â”‚
â”‚                                     â”‚
â”‚  Outer circles â†’ Inner circles âœ…   â”‚
â”‚  Inner circles â†’ Outer circles âŒ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Result:**

- Testable business logic
- Flexible infrastructure
- Independent of frameworks
- Independent of databases
- Independent of UI