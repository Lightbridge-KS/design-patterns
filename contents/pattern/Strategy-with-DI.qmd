---
title: "Strategy Pattern and Dependency Injection"
---

The Strategy Pattern **inherently uses Dependency Injection (DI)** as its mechanism for providing the algorithm to the Context.


## How DI Appears in Strategy Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DEPENDENCY INJECTION IN STRATEGY PATTERN               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  The Context DOES NOT create its own strategy.
  Instead, it RECEIVES the strategy from outside (injected).

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     Client       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â”‚ creates & injects
                             â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                                                         â”‚
  â”‚   strategy = LossyCompression()  â—„â”€â”€ Client creates     â”‚
  â”‚                     â”‚                                   â”‚
  â”‚                     â–¼                                   â”‚
  â”‚   context.set_strategy(strategy) â—„â”€â”€ Client injects     â”‚
  â”‚                                                         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     Context      â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚ - strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Just USES it
                    â”‚                  â”‚       (doesn't create)
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


## Two Common DI Approaches in Strategy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    1. SETTER INJECTION                              â”‚
â”‚                    (shown in your diagram)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    class Context:
        def __init__(self):
            self._strategy = None        # No strategy yet
        
        def set_strategy(self, strategy):   # â—„â”€â”€ Inject later
            self._strategy = strategy

    # Usage:
    context = Context()
    context.set_strategy(SomeStrategy())    # Inject via method
    context.set_strategy(OtherStrategy())   # Can swap anytime!

    âœ… Pros: Can change strategy at runtime
    âŒ Cons: Object may be in invalid state (no strategy set)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    2. CONSTRUCTOR INJECTION                         â”‚
â”‚                    (alternative approach)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    class Context:
        def __init__(self, strategy: Strategy):  # â—„â”€â”€ Inject at creation
            self._strategy = strategy

    # Usage:
    context = Context(SomeStrategy())    # Must provide strategy upfront

    âœ… Pros: Object always valid, clear dependencies
    âŒ Cons: Need new Context to change strategy (or add setter too)
```


## Python Example: Both Injection Types

```python
from abc import ABC, abstractmethod


# Strategy Interface
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> None:
        pass


# Concrete Strategies
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: float) -> None:
        print(f"ğŸ’³ Paid à¸¿{amount:,.2f} via Credit Card")


class QRPayment(PaymentStrategy):
    def pay(self, amount: float) -> None:
        print(f"ğŸ“± Paid à¸¿{amount:,.2f} via PromptPay QR")


class CashPayment(PaymentStrategy):
    def pay(self, amount: float) -> None:
        print(f"ğŸ’µ Paid à¸¿{amount:,.2f} in Cash")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTEXT WITH CONSTRUCTOR INJECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PaymentProcessorV1:
    """Strategy injected via constructor."""
    
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy  # Injected at construction
    
    def checkout(self, amount: float) -> None:
        print(f"Processing payment of à¸¿{amount:,.2f}...")
        self._strategy.pay(amount)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTEXT WITH SETTER INJECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PaymentProcessorV2:
    """Strategy injected via setter method."""
    
    def __init__(self):
        self._strategy: PaymentStrategy | None = None
    
    def set_strategy(self, strategy: PaymentStrategy) -> None:
        self._strategy = strategy  # Injected via setter
    
    def checkout(self, amount: float) -> None:
        if self._strategy is None:
            raise ValueError("Payment strategy not set!")
        print(f"Processing payment of à¸¿{amount:,.2f}...")
        self._strategy.pay(amount)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTEXT WITH BOTH (Most Flexible)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PaymentProcessorV3:
    """Strategy injected via constructor with optional setter."""
    
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy
    
    def set_strategy(self, strategy: PaymentStrategy) -> None:
        self._strategy = strategy  # Can change later if needed
    
    def checkout(self, amount: float) -> None:
        print(f"Processing payment of à¸¿{amount:,.2f}...")
        self._strategy.pay(amount)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# USAGE EXAMPLES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def main():
    print("=" * 50)
    print("V1: Constructor Injection")
    print("=" * 50)
    
    processor1 = PaymentProcessorV1(CreditCardPayment())
    processor1.checkout(1500.00)
    # To change strategy, need new instance:
    processor1_new = PaymentProcessorV1(QRPayment())
    processor1_new.checkout(750.00)
    
    print("\n" + "=" * 50)
    print("V2: Setter Injection")
    print("=" * 50)
    
    processor2 = PaymentProcessorV2()
    processor2.set_strategy(QRPayment())
    processor2.checkout(300.00)
    processor2.set_strategy(CashPayment())  # Swap at runtime
    processor2.checkout(50.00)
    
    print("\n" + "=" * 50)
    print("V3: Both (Constructor + Setter)")
    print("=" * 50)
    
    processor3 = PaymentProcessorV3(CreditCardPayment())
    processor3.checkout(2000.00)
    processor3.set_strategy(QRPayment())  # Can still swap
    processor3.checkout(500.00)


if __name__ == "__main__":
    main()
```


## Output

```
==================================================
V1: Constructor Injection
==================================================
Processing payment of à¸¿1,500.00...
ğŸ’³ Paid à¸¿1,500.00 via Credit Card
Processing payment of à¸¿750.00...
ğŸ“± Paid à¸¿750.00 via PromptPay QR

==================================================
V2: Setter Injection
==================================================
Processing payment of à¸¿300.00...
ğŸ“± Paid à¸¿300.00 via PromptPay QR
Processing payment of à¸¿50.00...
ğŸ’µ Paid à¸¿50.00 in Cash

==================================================
V3: Both (Constructor + Setter)
==================================================
Processing payment of à¸¿2,000.00...
ğŸ’³ Paid à¸¿2,000.00 via Credit Card
Processing payment of à¸¿500.00...
ğŸ“± Paid à¸¿500.00 via PromptPay QR
```


## The Relationship

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           STRATEGY PATTERN vs DEPENDENCY INJECTION                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   STRATEGY PATTERN      â”‚      â”‚  DEPENDENCY INJECTION   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         â”‚      â”‚                         â”‚
â”‚  WHAT: A behavioral     â”‚      â”‚  HOW: A technique for   â”‚
â”‚  pattern for swapping   â”‚      â”‚  providing dependencies â”‚
â”‚  algorithms             â”‚      â”‚  to objects             â”‚
â”‚                         â”‚      â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                  â”‚
            â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  OVERLAP  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚           â”‚
                      â”‚ Strategy  â”‚
                      â”‚ Pattern   â”‚
                      â”‚ USES DI   â”‚
                      â”‚ to inject â”‚
                      â”‚ algorithmsâ”‚
                      â”‚           â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Strategy Pattern = WHAT to inject (algorithm/behavior)
  Dependency Injection = HOW to inject (mechanism)
```


## Key Insight

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Without DI (tight coupling):                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚                                                                 â”‚
â”‚  class Context:                                                 â”‚
â”‚      def __init__(self):                                        â”‚
â”‚          self._strategy = ConcreteStrategyA()  # âŒ Hardcoded!  â”‚
â”‚                                                                 â”‚
â”‚  â€¢ Context controls WHICH strategy                              â”‚
â”‚  â€¢ Cannot change without modifying Context                      â”‚
â”‚  â€¢ Hard to test                                                 â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  With DI (loose coupling):                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚                                                                 â”‚
â”‚  class Context:                                                 â”‚
â”‚      def __init__(self, strategy: Strategy):                    â”‚
â”‚          self._strategy = strategy  # âœ… Injected from outside  â”‚
â”‚                                                                 â”‚
â”‚  â€¢ Client controls WHICH strategy                               â”‚
â”‚  â€¢ Context only depends on interface                            â”‚
â”‚  â€¢ Easy to test with mock strategies                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```